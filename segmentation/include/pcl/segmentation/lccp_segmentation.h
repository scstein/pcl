/*
 * Software License Agreement (BSD License)
 *
 *  Point Cloud Library (PCL) - www.pointclouds.org
 *
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of Willow Garage, Inc. nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *
 */


#ifndef PCL_SEGMENTATION_LCCP_H_
#define PCL_SEGMENTATION_LCCP_H_

#include <pcl/pcl_base.h>
#include <pcl/point_types.h>
#include <pcl/point_cloud.h>
#include <pcl/segmentation/supervoxel_clustering.h>

#define PCL_INSTANTIATE_LCCPSegmentation(T) template class PCL_EXPORTS pcl::LCCPSegmentation<T>;


namespace pcl
{
  /** \brief A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connected supervoxels separated by concave borders.
  * \author Simon Christoph Stein
  */
  template <typename PointT>
  class LCCPSegmentation
  {

    /** \brief Edge Properties stored in the adjacency graph.*/
    struct EdgeProperties
    {
//           float weight;
        bool isConvex;

        EdgeProperties():isConvex(false) { }
      };


  public:

    // Adjacency list with nodes holding labels (uint32_t) and edges holding EdgeProperties.
    typedef typename boost::adjacency_list<boost::setS, boost::setS, boost::undirectedS, uint32_t, EdgeProperties> SupervoxelAdjacencyList;
    typedef typename  boost::graph_traits<SupervoxelAdjacencyList>::vertex_iterator VertexIterator;
    typedef typename  boost::graph_traits<SupervoxelAdjacencyList>::adjacency_iterator AdjacencyIterator;

    typedef typename  boost::graph_traits<SupervoxelAdjacencyList>::vertex_descriptor VertexID;
    typedef typename  boost::graph_traits<SupervoxelAdjacencyList>::edge_iterator EdgeIterator;
    typedef typename  boost::graph_traits<SupervoxelAdjacencyList>::out_edge_iterator OutEdgeIterator;
    typedef typename  boost::graph_traits<SupervoxelAdjacencyList>::edge_descriptor EdgeID;



    LCCPSegmentation ();
    virtual ~LCCPSegmentation ();

    /** \brief Reset internal memory.  */
    void
    reset();

    /** \brief Merge supervoxels using local convexity. The input parameters are generated by using the SupervoxelClustering class.
      *  \param[in] supervoxel_clusters_arg map of < supervoxel labels, supervoxels >
      *  \param[in] label_adjacency_arg the graph defining the supervoxel adjacency relations
      */
    void
    segment(std::map <uint32_t, typename pcl::Supervoxel<PointT>::Ptr > &supervoxel_clusters_arg,  std::multimap<uint32_t, uint32_t> &label_adjacency_arg);

    /** \brief Relabels cloud with supervoxel labels with the computed segment labels
    *  \param[in] labeled_cloud Cloud to relabel */
    void
    relabelCloud(pcl::PointCloud< pcl::PointXYZL >::Ptr labeled_cloud_arg);

    /**  \brief Get map < SegmentID, std::vector< SuperVoxel IDs> >
      * \param[out] segment_map_arg the output container */
    void
    getSegmentSupervoxelMap( std::map<uint32_t, std::vector<uint32_t> >& segment_map_arg ) const;

    /** \brief Get map < SegmentID, std::set< Neighboring SegmentIDs> >
      * \param[out] segment_map_arg map < SegmentID, std::set< Neighboring SegmentIDs> > */
    void
    getSegmentAdjacencyMap(std::map< uint32_t, std::set< uint32_t > >& segment_adjacency_map_arg);

    /** \brief Get normal threshold
      *  \return the concavity tolerance angle in [deg] that is currently set */
    float
    getConcavityToleranceThreshold() const {
      return (concavity_tolerance_threshold_);
    }

    /** \brief Set normal threshold
      *  \param[out] concavity_tolerance_threshold_arg the concavity tolerance angle in [deg] to set */
    void
    setConcavityToleranceThreshold(float concavity_tolerance_threshold_arg) {
      concavity_tolerance_threshold_ = concavity_tolerance_threshold_arg;
    }

    /** \brief Segments smaller than segment_size are assigned to label of largest neighbor.
      * \param[in] filter_size segments smaller than this size will be filtered
    * \note Currently this runs multiple times, until no segment < filter_size is found. Could be faster. */
    void
    removeNoise(uint32_t filter_size);

    /** \brief Determines if a smoothness check is done during segmentation, trying to invalidate edges of non-smooth connected edges (steps). Two supervoxels are unsmooth if their plane-to-plane distance DIST > (expected_distance + smoothness_threshold_*voxel_resolution_). For parallel supervoxels, the expected_distance is zero.
      *  \param[in] use_smoothness_check_ Determines if the smoothness check is used
      *  \param[in] voxel_res The voxel resolution used for the supervoxels that are segmented
      *  \param[in] seed_res The seed resolution used for the supervoxels that are segmented
      *  \param[in] smoothness_threshold_arg Threshold (/fudging factor) for smoothness constraint according to the above formula. */
    void
    setSmoothnessCheck(bool use_smoothness_check_arg, float voxel_res_arg, float seed_res_arg, float smoothness_threshold_arg = 0.1)
    {
      use_smoothness_check_ = use_smoothness_check_arg;
      voxel_resolution_ = voxel_res_arg;
      seed_resolution_ = seed_res_arg;
      smoothness_threshold_ = smoothness_threshold_arg;
    }

    /** \brief Get the supervoxel adjacency graph with classified edges (boost::adjacency_list).
      *  \return the supervoxel adjacency list with classified (convex/concave) edges */
    SupervoxelAdjacencyList&
    getSVAdjacencyList()
    {
      if(grouping_data_valid_) return (sv_adjacency_list_);
      else
      {
        std::cerr << "SVCCSegmentation::getSVAdjacencyList: Error: Adjacency List invalid (call segment first)." << std::endl;
        exit(EXIT_FAILURE);
      }
    }

    /** \brief Set the value used for k convexity. For k>0 convex connections between p_i and p_j require k common neighbors of these patches that have a convex connection to both.
      *  \param[in] k factor used for extended convexity check */
    void
    setKFactor(uint k) {
        k_factor_ = k;
    }



  protected:

    /** \brief Computes the norm of the given vector
    * \param[in] x Vector to compute norm of.
    * \return Norm of vector x */
    float vecNorm(const pcl::Normal& x) const;
    float vecNorm(const pcl::PointXYZ& x) const;

    /** \brief Computes the dotproduct of the normals of two vectors
    * \param[in] x First vector
    * \param[in] y Second vector
    * \return Dotproduct of x and y  */
    float dotProduct(const pcl::Normal& x, const pcl::Normal& y)  const;
    float dotProduct(const pcl::PointXYZ& x, const pcl::PointXYZ& y)  const;
    float dotProduct(const pcl::PointXYZ& x, const pcl::Normal& y)  const;
    float dotProduct(const pcl::Normal& x, const pcl::PointXYZ& y)  const;

    /** \brief Computes the cross-product of the given normal vectors
    * \param[in] x First Normal
    * \param[in] y Second Normal
    * \return Normal storing crossp of x and y in its normal   */
    pcl::Normal
    crossP(const pcl::Normal& x, const pcl::Normal& y) const;

    /** \brief Normalize vector to length 1.
    *  \param[in] x Normal to normlize.  */
    void normalizeVec(pcl::Normal& x) const;
    void normalizeVec(pcl::PointXYZ& x) const;



  private:


    /** \brief Compute the adjacency of the segments */
    void
    computeSegmentAdjacency();

    /** \brief Is called within groupSupervoxels mainly to reserve required memory.
      *  \param[in] supervoxel_clusters_arg map of < supervoxel labels, supervoxels >
      *  \param[in] label_adjacency_arg the graph defining the supervoxel adjacency relations
      */
    void
    prepareSegmentation(const std::map <uint32_t, typename pcl::Supervoxel<PointT>::Ptr > &supervoxel_clusters_arg, const std::multimap<uint32_t, uint32_t> &label_adjacency_arg);

    /** \brief Assigns neighbors of the query point to the same group as the query point. Recursive part of groupSupervoxels(..). Grouping is done by a depth-search of nodes in the adjacency-graph.
      *  \param[in] queryPointID ID of point whose neighbors will be considered for grouping
      *  \param[in] group_label ID of the group/segment the queried point belongs to
      */
    void
    recursiveGrouping(VertexID const &queryPointID, unsigned int const group_label);

    /** \brief Calculates convexity of edges and saves this to the adjacency graph.
      *  \param[in] adjacency_list the supervoxel adjacency list*/
    void
    calculateConvexConnections(SupervoxelAdjacencyList& adjacency_list);

    /** \brief Connections are only convex if this is true for at least k common neighbors of the two patches. Call setKFactor(..) before segment(..) to use this.
      *  \param[in] k factor used for extended convexity check */
    void
    applyKconvexity(uint k);

    /** \brief Returns true if the connection between source and target is convex.
      *  \param[in] source_label Label of one Supervoxel connected to the edge that should be checked
      *  \param[in] target_label Label of the other Supervoxel connected to the edge that should be checked
      *  \return True if connection is convex */
    bool
    connIsConvex(uint32_t source_label, uint32_t target_label);


    ///  *** Parameters *** ///

    /** \brief Normal Threshold in degrees [0,180] used for merging */
    float concavity_tolerance_threshold_;

    /** \brief Marks if valid grouping data (sv_adjacency_list_, svLabel_segLabel_map_, processed_) is avaiable */
    bool grouping_data_valid_;

    /** \brief Determines if the smoothness check is used during segmentation*/
    bool use_smoothness_check_;

    /** \brief Two supervoxels are unsmooth if their plane-to-plane distance DIST >  (expected_distance + smoothness_threshold_*voxel_resolution_). For parallel supervoxels, the expected_distance is zero. */
    float smoothness_threshold_;

    /** \brief Seed resolution of the supervoxels (used only for smoothness check) */
    float seed_resolution_;

    /** \brief voxel resolution used to build the supervoxels (used only for smoothness check)*/
    float voxel_resolution_;

    /** \brief factor used for k-convexity */
    uint k_factor_;


    /** \brief Stores which SuperVoxel labels were already visited during recursive grouping.    processed_[sv_Label] = false (default)/true (already processed) */
    std::map<uint32_t, bool> processed_;

    /** \brief Adjacency graph with the supervoxel labels as nodes and edges between adjacent supervoxels */
    SupervoxelAdjacencyList sv_adjacency_list_;

    /** \brief map from the supervoxel labels to the supervoxel objects  */
    std::map <uint32_t, typename pcl::Supervoxel<PointT>::Ptr > svLabel_supervoxel_map_;

    /** \brief Storing relation between original SuperVoxel Labels and new segmantion labels. svLabel_segLabel_map_[old_labelID] = new_labelID */
    std::map<uint32_t, uint32_t> svLabel_segLabel_map_;

    /** \brief map < Segment Label, std::vector< SuperVoxel Labels> > */
    std::map< uint32_t, std::vector< uint32_t > > segLabel_svlist_map_;

    /** \brief map < SegmentID, std::vector< Neighboring segment labels> > */
    std::map< uint32_t, std::set< uint32_t > > segLabel_neighborSet_map_;


  };
}

#endif // PCL_SEGMENTATION_LCCP_H_
